<?xml version="1.0" encoding="utf-8"?><testsuite errors="2" failures="0" name="pytest" skipped="0" tests="5" time="0.700"><testcase classname="Tests.API.test_movie_api.MovieAPITest" file="Tests/API/test_movie_api.py" line="11" name="test_movies_api_all_movies" time="0.027"></testcase><testcase classname="Tests.API.test_movie_api.MovieAPITest" file="Tests/API/test_movie_api.py" line="31" name="test_movies_api_post_new_movie" time="0.008"></testcase><testcase classname="Tests.API.test_movie_api.MovieAPITest" file="Tests/API/test_movie_api.py" line="15" name="test_movies_api_search_star_wars" time="0.029"></testcase><testcase classname="Tests.API.test_proxy_api.ProxyAPITest" file="Tests/API/test_proxy_api.py" line="24" name="test_proxy_api_validate_admin_has_admin_rights" time="0.044"><error message="test setup failure">cls = &lt;class &apos;test_proxy_api.ProxyAPITest&apos;&gt;

    @classmethod
    def setup_class(cls):
&gt;       cls.admin_session = ProxyAPI(APITestBase.ProxyUrl, User(username=&apos;testadmin&apos;, password=&apos;admin&apos;, id=1))

Tests/API/test_proxy_api.py:14: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
Services/Proxy/ProxyAPI.py:10: in __init__
    self.token = self.get_token(user)
Services/Proxy/ProxyAPI.py:18: in get_token
    token = json.loads(response.content.decode(&apos;utf-8&apos;))[&apos;access_token&apos;]
/usr/lib/python3.6/json/__init__.py:354: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.6/json/decoder.py:339: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;json.decoder.JSONDecoder object at 0x7f3fd5ddf898&gt;
s = &apos;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 3.2 Final//EN&quot;&gt;\n&lt;title&gt;500 Internal Server Error&lt;/title&gt;\n&lt;h1&gt;Internal Serve...d was unable to complete your request.  Either the server is overloaded or there is an error in the application.&lt;/p&gt;\n&apos;, idx = 0

    def raw_decode(self, s, idx=0):
        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        &quot;&quot;&quot;
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.6/json/decoder.py:357: JSONDecodeError</error></testcase><testcase classname="Tests.API.test_proxy_api.ProxyAPITest" file="Tests/API/test_proxy_api.py" line="16" name="test_proxy_api_validate_admin_token" time="0.000"><error message="test setup failure">cls = &lt;class &apos;test_proxy_api.ProxyAPITest&apos;&gt;

    @classmethod
    def setup_class(cls):
&gt;       cls.admin_session = ProxyAPI(APITestBase.ProxyUrl, User(username=&apos;testadmin&apos;, password=&apos;admin&apos;, id=1))

Tests/API/test_proxy_api.py:14: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
Services/Proxy/ProxyAPI.py:10: in __init__
    self.token = self.get_token(user)
Services/Proxy/ProxyAPI.py:18: in get_token
    token = json.loads(response.content.decode(&apos;utf-8&apos;))[&apos;access_token&apos;]
/usr/lib/python3.6/json/__init__.py:354: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.6/json/decoder.py:339: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;json.decoder.JSONDecoder object at 0x7f3fd5ddf898&gt;
s = &apos;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 3.2 Final//EN&quot;&gt;\n&lt;title&gt;500 Internal Server Error&lt;/title&gt;\n&lt;h1&gt;Internal Serve...d was unable to complete your request.  Either the server is overloaded or there is an error in the application.&lt;/p&gt;\n&apos;, idx = 0

    def raw_decode(self, s, idx=0):
        &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        &quot;&quot;&quot;
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
&gt;           raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.6/json/decoder.py:357: JSONDecodeError</error></testcase></testsuite>